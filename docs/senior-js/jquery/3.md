### 链表有关题目

#### 1.[合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

![img](3.assets/merge_ex1.jpg)

```python
struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2){
  struct ListNode *p, *q,*r;
  struct ListNode *list3=(struct ListNode *)malloc(sizeof(struct ListNode));
   p=list1;
  q=list2;
  r=list3;
  if(!p&&!q){
      return NULL;
  }
  if(p&&!q){
      return p;
  }
  if(!p&&q){
      return q;
  }
 
  while(p&&q){
      if(p->val<q->val){
      r->next=p;
      r=r->next;
      p=p->next;
            }
            else{
      r->next=q;
      r=r->next;
      q=q->next;
            }
  }
if(p!=NULL){
    r->next=p;
}
if(q!=NULL){
    r->next=q;
}
return list3->next;
}
```

思路：新建一个链表，逐个插入即可

问题：malloc（）方法的使用问题。该函数返回一个指针 ，指向已分配大小的内存。如果请求失败，则返回 NULL。

#### 2.[相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

![img](3.assets/160_statement.png)

方法一：时间复杂度 空间复杂度高 

```python
struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {
    struct ListNode *p,*q;
    p=headA;
    q=headB;
    while(p&&q){
    
        if(p==q)return p;
        while(q){
            q=q->next;
            if(p==q)return p;
        }
        p=p->next;
        q=headB;

    }
    return NULL;
}
```

思路：双循环，用b上的每一个结点和a上的结点依次比较

补充：条件运算符（conditional operator）有时候也称为三元运算符（ternary operator，或者trinary operator），因为它是唯一需要 3 个操作数的运算符：**条件 ? 表达式1 : 表达式2**

方法二：

```python
struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {
        struct ListNode *p, *q;

        for (p = headA, q = headB; p != q; ){
            if (p != NULL)
                p = p->next;
            else p = headB;
            if (q != NULL)
                q = q->next;
            else q = headA;
        }

        return p;
}

```

思路：双指针，两个指针将图中的每一个点都遍历了一遍，所以会指向同一结点

![Picture1.png](3.assets/1615224578-EBRtwv-Picture1.png)

#### 3.[反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)

```c
struct ListNode* reverseList(struct ListNode* head){
struct ListNode* p,*q,*r;

p=head;
if(!p){return NULL;}
q=p->next;
p->next=NULL;
if(!q) {return head;}
r=q->next;
while(r){
    q->next=p;
    p=q;
    q=r;
    r=r->next;
    
}
q->next=p; 
return q;
}
```

思路：![img](3.assets/D411DEAF317DC7581FCB7111B385AF8F.jpg)

#### 4.[分隔链表](https://leetcode-cn.com/problems/partition-list/)

给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。

你应当 保留 两个分区中每个节点的初始相对位置。

![img](https://assets.leetcode.com/uploads/2021/01/04/partition.jpg)

```c
struct ListNode* partition(struct ListNode* head, int x){
struct ListNode *small,*large,*p,*q,*r;
if(!head)return NULL;
p=head;
small=malloc(sizeof(struct ListNode));
large=malloc(sizeof(struct ListNode));
q=small;
r=large;
while(p){
    if(p->val<x){
     small->next=p;
     small=small->next; 
     p=p->next;
    }
    else{
   large->next=p;
   large=large->next;
   p=p->next;
    }
   
}

large->next=NULL;
 small->next=r->next;

return q->next;}
```

思路：按顺序将小于x的组合为一个链表，大于等于x的组合为一个链表，最后将两链表合并
